{"version":3,"sources":["webpack://tritra/webpack/universalModuleDefinition","webpack://tritra/webpack/bootstrap","webpack://tritra/./src/lib/TouchPoint.js","webpack://tritra/./src/lib/Vector2d.js","webpack://tritra/./src/lib/MathUtils.js","webpack://tritra/./src/lib/Triangle.js","webpack://tritra/./src/lib/Match.js","webpack://tritra/./src/lib/Recognizer.js","webpack://tritra/./src/lib/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TouchPoint","point","groups","isPaired","Vector2d","x","y","u","Math","sqrt","pow","MathUtils","v1","v2","start","end","amount","radians","PI","Triangle","p1","p2","p3","dist","distance","diff01m02","abs","diff02m12","diff01m12","a","b","middlePoint","lerp","diff","normalize","radToDeg","atan2","ab","cb","dot","cross","alpha","floor","Match","index","matchedAngle","triangle","getApex","getApexAngle","getCenter","getOrientation","Recognizer","vertexAngles","options","maxPointDistance","maxAngleTolerance","apexAngles","points","touchPoints","length","tp","push","groupIdx","j","polygons","polygonPoints","i2","j2","polygonsUnique","exists","k","matches","apexAngle"],"mappings":"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","file":"js/tritra.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tritra\"] = factory();\n\telse\n\t\troot[\"tritra\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class TouchPoint {\n\n  // construction\n  constructor(point) {\n    this.point = point;\n    this.groups = [];\n    this.isPaired = false;\n  }\n  //----------------------------------------------------------------------------\n}\n","export default class Vector2d {\n\n  // construction\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  //----------------------------------------------------------------------------\n\n  // accessors\n  normalize() {\n\n    let u = new Vector2d(\n      this.x / Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)),\n      this.y / Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))\n    );\n\n    this.x = u.x;\n    this.y = u.y;\n  }\n  //----------------------------------------------------------------------------\n}\n","export default class MathUtils {\n\n  /**\n   * calculate the distance between two vectors\n   * @param {Vector2d} v1\n   * @param {Vector2d} v2\n   * @return {number} The distance\n   */\n  static distance(v1, v2) {\n    return Math.sqrt(\n      Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2)\n    );\n  }\n\n  /**\n   * linear interpolation of two values with given increase\n   * @param {number} start\n   * @param {number} end\n   * @param {number} amount\n   * @return {number} Interpolated value\n   */\n  static lerp(start, end, amount) {\n    return (1 - amount) * start + amount * end;\n  }\n\n  /**\n   * radians to degree conversion\n   * @param {number} radians\n   * @return {number} degree value\n   */\n  static radToDeg(radians) {\n    return radians * (180 / Math.PI);\n  }\n}\n","import Vector2d from \"./Vector2d\";\nimport MathUtils from \"./MathUtils\";\n\nexport default class Triangle {\n\n  // construction\n  constructor(p1, p2, p3) {\n\n    let dist = [\n      MathUtils.distance(p1, p2),\n      MathUtils.distance(p2, p3),\n      MathUtils.distance(p1, p3)\n    ];\n\n    // identify apex\n    // (b will always be the apex)\n\n    let diff01m02 = Math.abs(dist[0] - dist[2]),\n        diff02m12 = Math.abs(dist[2] - dist[1]),\n        diff01m12 = Math.abs(dist[0] - dist[1]);\n\n    if(diff01m02 < diff02m12 && diff01m02 < diff01m12) {\n      this.a = p2;\n      this.b = p1;\n      this.c = p3;\n    }\n    else if(diff01m12 < diff01m02 && diff01m12 < diff02m12) {\n      this.a = p1;\n      this.b = p2;\n      this.c = p3;\n    }\n    else if(diff02m12 < diff01m02 && diff02m12 < diff01m12) {\n      this.a = p1;\n      this.b = p3;\n      this.c = p2;\n    }\n\n    // @TODO: throw error?\n  }\n  //----------------------------------------------------------------------------\n\n  /**\n   * Calculate orientation of triangle\n   * @return {number} orientation in degrees\n   */\n  getOrientation() {\n\n    let middlePoint = new Vector2d(\n      MathUtils.lerp(this.a.x, this.c.x, 0.5),\n      MathUtils.lerp(this.a.y, this.c.y, 0.5)\n    );\n\n    let diff = new Vector2d(this.b.x - middlePoint.x, this.b.y - middlePoint.y);\n    diff.normalize();\n\n    return MathUtils.radToDeg(Math.atan2(diff.x, diff.y)) * -1;\n  }\n\n  /**\n   * Calculate altitude of triangle\n   * @return {number} altitude\n   */\n  getAltitude() {\n\n    let middlePoint = new Vector2d(\n      MathUtils.lerp(this.a.x, this.c.x, 0.5),\n      MathUtils.lerp(this.a.y, this.c.y, 0.5)\n    );\n\n    return MathUtils.distance(middlePoint, this.b);\n  }\n\n  /**\n   * Calculate apex angle of triangle\n   * @return {number} apex angle in degrees\n   */\n  getApexAngle() {\n\n    let ab = new Vector2d(this.b.x - this.a.x, this.b.y - this.a.y);\n    let cb = new Vector2d(this.b.x - this.c.x, this.b.y - this.c.y);\n\n    let dot = (ab.x * cb.x + ab.y * cb.y); // dot product\n    let cross = (ab.x * cb.y - ab.y * cb.x); // cross product\n    let alpha = Math.atan2(cross, dot);\n\n    return Math.abs(Math.floor(alpha * 180 / Math.PI + 0.5));\n  }\n\n  /**\n   * Calculate width of triangle\n   * @return {number} width\n   */\n  getWidth() {\n    return MathUtils.distance(this.a, this.c);\n  }\n\n  /**\n   * Calculate center point\n   * @return {Vector2d} center point\n   */\n  getCenter() {\n    return new Vector2d(\n      (this.a.x + this.b.x + this.c.x) / 3,\n      (this.a.y + this.b.y + this.c.y) / 3\n    );\n  }\n\n  /**\n   * Find apex point\n   * @return {Vector2d} apex point\n   */\n  getApex() {\n    return this.b;\n  }\n}\n","export default class Match {\n\n  /**\n   * New match for triangle recognizer\n   * @param {number} index index of matched angle\n   * @param {number} matchedAngle the matched apex angle (not the actual angle!)\n   * @param {Triangle} triangle matching triangle\n   */\n  constructor(index, matchedAngle, triangle) {\n    this.index = index;\n    this.matchedAngle = matchedAngle;\n    this.triangle = triangle;\n  }\n  //----------------------------------------------------------------------------\n\n  // delegation methods for convenience\n\n  /**\n   * Find apex point\n   * @return {Vector2d} apex point\n   */\n  getApex() {\n    return this.triangle.getApex();\n  }\n\n  /**\n   * Calculate apex angle of triangle\n   * @return {number} apex angle in degrees\n   */\n  getApexAngle() {\n    return this.triangle.getApexAngle();\n  }\n\n  /**\n   * Calculate center point\n   * @return {Vector2d} center point\n   */\n  getCenter() {\n    return this.triangle.getCenter();\n  }\n\n  /**\n   * Calculate orientation of triangle\n   * @return {number} orientation in degrees\n   */\n  getOrientation() {\n    return this.triangle.getOrientation();\n  }\n  //----------------------------------------------------------------------------\n}\n","import TouchPoint from \"./TouchPoint\";\nimport Vector2d from \"./Vector2d\";\nimport Triangle from \"./Triangle\";\nimport Match from \"./Match\";\nimport MathUtils from \"./MathUtils\";\n\nexport default class Recognizer {\n\n  /**\n   * Main recognizer instance\n   * @param {number[]} vertexAngles Apex angles you want to track\n   * @param {Object} options Configuration options\n   */\n  constructor(vertexAngles, options = {}) {\n\n    // read options\n    this.options = {...{\n      maxPointDistance: 150,\n      maxAngleTolerance: 5\n    }, ...options};\n\n    // apex angles to identify\n    this.apexAngles = vertexAngles;\n  }\n\n  /**\n   * Recognize triangle objects within a set of given points\n   * @param {Vector2d[]} points Set of points for recognizer to analyze\n   * @return {Matches[]} Array of matches\n   */\n  findMatches(points) {\n\n    // collect raw points\n    //-------------------\n\n    let touchPoints = [];\n    for(let i = 0; i < points.length; i++) {\n      let tp = new TouchPoint(points[i]);\n      tp.isPaired = false;\n      touchPoints.push(tp);\n    }\n\n\n    // find all pairs\n    //---------------\n\n    // count group index\n    let groupIdx = 0;\n\n    for(let i = 0; i < touchPoints.length; i++) {\n      for(let j = 0; j < touchPoints.length; j++) {\n\n        // no need to compare (same)\n        if(i === j) { continue; }\n\n        let tpDistance = MathUtils.distance(touchPoints[i].point, touchPoints[j].point);\n        if(tpDistance <= this.options.maxPointDistance) {\n\n          if(touchPoints[i].isPaired && touchPoints[j].isPaired) {\n            // both already paired\n            // skip points\n          }\n          else {\n            // found a new pair\n            groupIdx++;\n            touchPoints[i].groups.push(groupIdx);\n            touchPoints[j].groups.push(groupIdx);\n            touchPoints[i].isPaired = true;\n            touchPoints[j].isPaired = true;\n          }\n        }\n      }\n    }\n\n\n    // group pairs into polygons\n    //--------------------------\n\n    let polygons = [];\n\n    for(let i = 0; i < touchPoints.length; i++) {\n\n      if(touchPoints[i].groups.length > 1) {\n\n        // a point must belong to at least two pairs\n        // otherwise it will not be considered any further\n\n        let polygonPoints = [];\n\n        for(let i2 = 0; i2 < touchPoints[i].groups.length; i2++) {\n          for(let j = 0; j < touchPoints.length; j++) {\n            for(let j2 = 0; j2 < touchPoints[j].groups.length; j2++) {\n              if(touchPoints[i].groups[i2] == touchPoints[j].groups[j2]) {\n                polygonPoints.push(touchPoints[j].point);\n              }\n            }\n          }\n        }\n\n        if(polygonPoints.length > 0) {\n          polygonPoints.push(touchPoints[i].point);\n          polygons.push(polygonPoints);\n        }\n      }\n    }\n\n    // eliminate duplicates\n    //---------------------\n\n    let polygonsUnique = [];\n\n    for(let i = 0; i < polygons.length; i++) {\n\n      let polygonPoints = [];\n\n      if(polygons[i].length > 0) {\n\n        polygonPoints.push(polygons[i][0]);\n\n        for(let j = 0; j < polygons[i].length; j++) {\n\n          let exists = false;\n          for(let k = 0; k < polygonPoints.length; k++) {\n            if(polygonPoints[k] == polygons[i][j] || j == 0) {\n              exists = true;\n            }\n          }\n\n          if(exists == false) {\n            polygonPoints.push(polygons[i][j]);\n          }\n        }\n      }\n      polygonsUnique.push(polygonPoints);\n    }\n\n    // detect requested triangles\n    //---------------------------\n\n    let matches = [];\n\n    for(let i = 0; i < polygonsUnique.length; i++) {\n\n      if(polygonsUnique[i].length !== 3) {\n        // only consider triangles\n        continue;\n      }\n\n      let triangle = new Triangle(\n        polygonsUnique[i][0],\n        polygonsUnique[i][1],\n        polygonsUnique[i][2]\n      );\n\n      // calculate the apex angle\n      let apexAngle = triangle.getApexAngle();\n\n      // check if angle matches one of our requested triangles\n      for(let j = 0; j < this.apexAngles.length; j++) {\n\n        if(apexAngle > (this.apexAngles[j] - this.options.maxAngleTolerance) &&\n           apexAngle < (this.apexAngles[j] + this.options.maxAngleTolerance)\n        ) {\n          // add to matches\n          matches.push(new Match(j, this.apexAngles[j], triangle));\n        }\n      }\n\n    }\n\n    return matches;\n  }\n}","import Recognizer from './Recognizer';\nimport Triangle from './Triangle';\nimport Vector2d from './Vector2d';\nimport Match from './Match';\n\nexport { Recognizer, Triangle, Vector2d, Match };\n"],"sourceRoot":""}